const stringifyCss = require('css-stringify')
const parseCss = require('css-parse')
const indexOf = [].indexOf || function (item) {
  for (var i = 0, l = this.length; i < l; i++) {
    if (i in this && this[i] === item) return i
  }
  return -1
}
try {
  // eslint-disable-next-line global-require
  RawSource = require('webpack-sources').RawSource
} catch (e) {
  if (!(e instanceof Error) || e.code !== 'MODULE_NOT_FOUND') {
    throw e
  }
}
const group = function (css) {
  var emToPxRatio, i, intervalRules, len, m, media, mediaRules, medias, onlyMaxRules, onlyMinRules, otherRules, parsed,
    ref, rootRules, rule, rules
  parsed = parseCss(css)
  medias = {}
  rootRules = []
  ref = parsed.stylesheet.rules
  for (i = 0, len = ref.length; i < len; i++) {
    rule = ref[i]
    if (rule.type === 'media') {
      if (!medias[rule.media]) {
        medias[rule.media] = []
      }
      medias[rule.media] = medias[rule.media].concat(rule.rules)
    } else {
      rootRules.push(rule)
    }
  }
  mediaRules = []
  for (media in medias) {
    rules = medias[media]
    rule = {
      type: 'media',
      media: media,
      rules: rules
    }
    if (media.indexOf('min-width') !== -1) {
      m = media.match(/min-width:\s*(\d+)(px|em)?/)
      if (m && m[1]) {
        rule.minWidth = parseInt(m[1])
      }
      if (m[2]) {
        rule.unit = m[2]
      }
    }
    if (media.indexOf('max-width') !== -1) {
      m = media.match(/max-width:\s*(\d+)(px|em)?/)
      if (m && m[1]) {
        rule.maxWidth = parseInt(m[1])
      }
      if (m[2]) {
        rule.unit = m[2]
      }
    }

    mediaRules.push(rule)
  }
  onlyMinRules = mediaRules.filter(function (rule) {
    return (rule.minWidth != null) && (rule.maxWidth == null)
  })
  onlyMaxRules = mediaRules.filter(function (rule) {
    return (rule.maxWidth != null) && (rule.minWidth == null)
  })
  intervalRules = mediaRules.filter(function (rule) {
    return (rule.minWidth != null) && (rule.maxWidth != null)
  })
  otherRules = mediaRules.filter(function (rule) {
    return indexOf.call(onlyMinRules.concat(onlyMaxRules).concat(intervalRules), rule) < 0
  })
  emToPxRatio = 16
  onlyMinRules.sort(function (a, b) {
    var aPxValue, bPxValue
    aPxValue = a.minWidth
    bPxValue = b.minWidth
    if (a.unit === 'em') {
      aPxValue *= emToPxRatio
    }
    if (b.unit === 'em') {
      bPxValue *= emToPxRatio
    }
    return aPxValue - bPxValue
  })
  onlyMaxRules.sort(function (a, b) {
    var aPxValue, bPxValue
    aPxValue = a.maxWidth
    bPxValue = b.maxWidth
    if (a.unit === 'em') {
      aPxValue *= emToPxRatio
    }
    if (b.unit === 'em') {
      bPxValue *= emToPxRatio
    }
    return bPxValue - aPxValue
  })
  parsed.stylesheet.rules = rootRules.concat(onlyMinRules).concat(onlyMaxRules).concat(intervalRules).concat(otherRules)
  return stringifyCss(parsed)
}



module.exports = class LinkStylesheetHtmlWebpackPlugin {
  constructor(options) {
    this.options = options
  }

  apply(compiler) {
    compiler.hooks.thisCompilation.tap('MyPlugin', compilation => {
      compilation.plugin('optimize-chunk-assets', (chunks, callback) => {

        console.log('######')
        // console.log(chunks)
        chunks.forEach((chunk) => {
          // console.log(Object.keys(chunkList))
          chunk.files.forEach(function (filename) {
// console.log(chunk)
            // Get the asset source for each file generated by the chunk:
            // var source = compilation.assets[filename].source()
            if (/.*\.css$/.test(filename)) {
              console.log(chunk.name)
              console.log(chunk.id)
              // console.log(compilation)
              const source = compilation.assets[filename].source()
              // compilation.assets[filename].source('bibi')
              // console.log(Object.keys(chunk))
              // console.log(source)
              // console.log(compilation.assets[filename])
              // console.log(group(source))
              compilation.assets[filename] = new RawSource(group(source))


            }
          })

        })
        callback()

//         comp.chunks.forEach(function (chunk) {
//           // if (chunk.files.length) {
//
//           // console.log(chunk.files)
//           // console.log(chunk)
//           // }
//           // Explore each module within the chunk (built inputs):
//           // chunk.forEachModule(function (module) {
//           //   // Explore each source file path that was included into the module:
//           //   module.fileDependencies.forEach(function (filepath) {
//           //     // we've learned a lot about the source structure now...
//           //   })
//           // })
//
//           // Explore each asset filename generated by the chunk:
//           chunk.files.forEach(function (filename) {
// // console.log(chunk)
//             // Get the asset source for each file generated by the chunk:
//             // var source = compilation.assets[filename].source()
//             if (/.*\.css$/.test(filename)) {
//               // console.log(compilation)
//               // var source = compilation.assets[filename].source()
//               // compilation.assets[filename].source('bibi')
//               console.log(Object.keys(chunk))
//               console.log(compilation.assets[filename])
//               comp.assets[filename]
//             }
//           })
//         })
//         callback()
      })

    })

    // compiler.plugin('emit', function (compilation, callback) {

    // Explore each chunk (build output):
// console.log(compilation.assets)
//       compilation.chunks.forEach(function (chunk) {
//         // if (chunk.files.length) {
//
//         // console.log(chunk.files)
//         // console.log(chunk)
//         // }
//         // Explore each module within the chunk (built inputs):
//         // chunk.forEachModule(function (module) {
//         //   // Explore each source file path that was included into the module:
//         //   module.fileDependencies.forEach(function (filepath) {
//         //     // we've learned a lot about the source structure now...
//         //   })
//         // })
//
//         // Explore each asset filename generated by the chunk:
//         chunk.files.forEach(function (filename) {
// // console.log(chunk)
//           // Get the asset source for each file generated by the chunk:
//           // var source = compilation.assets[filename].source()
//           if (/.*\.css$/.test(filename)) {
//             // var source = compilation.assets[filename].source()
//             // compilation.assets[filename].source('bibi')
//             console.log(Object.keys(chunk))
//             console.log(compilation.assets[filename])
//             compilation.assets[filename]
//           }
//         })
//       })

    //   callback()
    // })
  }
}
